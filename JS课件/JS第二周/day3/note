### 预解释
- 在当前作用域下，在JS代码执行之前，我们会对带var的和带function进行声明或定义
- var 和 function的声明和定义不同
    + var：只声明，不定义
    + function：声明+定义
- 内存：栈内存+ 堆内存
栈内存：提供了一个供JS代码，运行的环境
    + 全局作用域
    + 私有作用域
堆内存：存储引用数据类型的数据
    + 函数数据类型：存代码字符串
    + 对象数据类型：存键值对；
- 内存释放：
## 栈内存的形成和释放：
### 全局作用域：
- 形成：当浏览器加载完页面的时候，全局作用域形成
- 销毁：关闭页面，关闭浏览器，关闭电脑...
### 私有作用域：
- 形成：当函数被调用的时候，形成私有作用域；
- 销毁：一般当函数执行完成的时候，私有作用域就释放了，但是特殊情况除外：
    + 不释放：如果函数中的东西，被外面的变量或其他占用的时候，就无法释放
    + 不立即释放：最典型的就是当函数执行完成的时候，返回一个函数的定义阶段，这个定义阶段，还要再被执行一次；当两次都执行完成的时候，私有作用域得到释放；
### 垃圾回收机制：
浏览器每隔一段事件，都会回收没用的内存，所以，当我们不用那个地址的时候，可以把占用这个地址的东西，指向空指针null;这样，等浏览器空闲的时候，就会把这个内存进行回收；

### 堆内存的释放
var obj={}
var fn=function(){alert(123)}
obj=null;
fn=null;

### 函数定义3阶段
1、开辟一个空间地址
2、把函数体内所有JS代码，作为字符串存在这个空间中
3、把这个空间地址赋值给函数名；

### 函数的调用4步骤
1、形成一个私有作用域
2、形参赋值
3、预解释：
4、代码从上到下的执行；

### 带var和不带var的区别：
- 带var的：1) 私有变量 2）会进行预解释
- 不带var: 1) 如果是设置，找不到，window.a=xxx; 如果是获取，找不到，报错 xxx is not defined; 2)不会进行预解释；

### 作用域链
当函数被调用的时候，会形成一个私有作用域，看这个私有作用域中，是否有私有变量a;
1)如果有,该函数中所有的a都是私有变量
2)没有，往上级作用域查找，一直找到window还没的话，就报错；

### 上级作用域：
- 上级作用域跟函数在哪里调用无关，只跟函数对应的堆内存，在哪个空间下开辟有关；

### 预解释无节操：
1）最对等号左边带var的声明，但不定义
2）条件判断语句，无论是否成立，都会进行预解释
    + 提示我们：永远不要在条件判断语句中，写函数的定义阶段；浏览器有兼容问题；
3）自执行函数不会进行预解释，只有执行到他的时候：声明+定义+调用 同步完成
4）已经声明过的，不会进行重复声明
5）return后面语句不会进行预解释，return下面的语句虽然不执行，但会进行预解释

### 函数的几种写法，写法不同，导致预解释就不同
1、 函数常规写法
```
function fn(){....}    //按照function进行预解释； 声明+定义  var fn=xxxx;
```
2、把函数赋值给变量；
 var fn=function(){}  //表达式的写法；按照变量的规则，进行预解释； var fn; 只声明，不定义
3、把函数作为值赋值给  对象.属性名；
```
oDiv.onClick=function(){};  //类似于 window.f=function(){} 不会进行预解释
```
4、自执行函数
```
(function(){})();   //按照预解释中自执行函数的规定； 不会进行预解释，执行到的时候，声明+定义+调用 同步完成；
```




















