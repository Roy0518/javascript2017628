### 预解释分析规律
1）预解释
2）代码从上到下的执行；
3）当我们遇到"函数定义阶段"的时候，不管，因为在预解释阶段，函数已经声明+定义过了；
4）当我们遇到"函数调用阶段"的时候
    + 形成私有作用域
    + 形参赋值
    + 预解释
    + 代码从上到下的执行
    **注意：在函数调用，一定要顺带写上"该函数对应的内存地址"，因为找上级作用域的时候要用到**
- 上级作用域：上级作用域跟函数在哪里调用无关，只跟该函数对应的堆内存在哪里开辟有关；

### 关注
1、内存和内存释放：
    1）不释放    i i++
    2）不立即释放
    3）就释放：一点私有作用域得到释放，函数的每次调用之间，没有任何关系；
2、预解释无节操
    1、 只对等号左边带var的，声明但不定义
    2、 声明过的不会进行重复声明，但会重新赋值；
    3、 自执行函数不会进行预解释，只有执行到的他的时候，声明+定义+调用同步完成
    4、 (针对IE10及10以下) 条件判断语句中，无论条件是否成立，都会进行预解释
    5、 return后面的语句，不会进行预解释；return下面的语句，虽然不执行，但会进行预解释；
3、this
    1、 当函数被调用的以后，看前面是否有"."，点前面是谁，this就是谁；
    2、 当元素身上的事件，被触发的时候，会执行一个函数，函数中的this，指向当前这个元素
    3、 自执行函数中的this-window；
    4、 回调函数中的this，一般是window；
    5、 构造函数中的this，都是实例；
4、带var和不带var
    1、带var：1）会预解释 2）在私有作用域下，是私有变量
    2、不带var：1）不会预解释 2）在私有作用域下，是window的全局属性；
5、 运算符的优先级
- 算术》比较》逻辑》赋值；

////////////////////
### 对象2大特征：1）属性 2）方法
### 面向对象的特点
- 封装：低耦合高內聚；（ 同样的功能，只需要写一次，把他封装起来，以后在遇到类似的功能，只需要调用即可；可以避免大量冗余代码；）
- 继承：子类继承父类的属性和方法；
- 多态：包含重载和重写
    + 重载：JS中没有严格意义上的重载，但是有类似重载的功能，就是传不同的参数可以实现不同的需求
    + 重写：子类可以重写父类的属性和方法；
### 面试对象设计思想
- 单例模式：把描述同一对象的属性和方法，都放在同一个命名空间下；
    + 本质就是对象 {};
    + 模块化开发的思想：对于一个大型项目，我们会分配给不同的前端人员一起开发，各自负责各自的模块，等开发完成的时候，进行进行代码合并；
    + 单例模式在开发中
        1、不同模块之间的相互调用:对象.属性名
        2、同一模块之间的相互调用：this.属性名；
    + 优点：
        1、最常用最简单的模块化开发
        2、避免全局变量的冲突
        3、可以模块之间的相互调用；
    + 缺点：当对象特别多，每个对象都有类似的属性和方法，会造成大量的冗余代码；
        + 解决办法：工厂模式；
- 工厂模式
    + 本质就是：普通的函数封装
    ```
    //new Person()
    function person(name,age) {
            // 1)创建一个空对象；
            var obj={};
            //2)加工对象：本质就是给对象添加属性和方法；
            obj.name=name;
            obj.age=age;
            obj.showName=function () {
                //当元素身上的事件，被触发的时候，会执行一个函数，函数中的this，指向当前这个元素；
                alert('我的名字是'+this.name)
            }
            // 3) 返回对象；
            return obj;
    }
    ```
    + 工厂模式主要包含三步
        1、引进原材料   var obj={}
        2、加工原材料   给对象添加属性和方法
        3、输出产成品   返回对象；
    + 优点：避免大量冗余代码，提高开发效率；
    + 不足点：长得跟系统方法不一样
        1、首字母小写，系统大写
        2、没有new;
- 构造函数模式
    + 构造函数和工厂模式的区别
        + 从函数内在的区别
            1、工厂模式有三步：1）创建空对象 2）加工对象：给对象添加实例和方法 3）返回对象
            2、构造函数有1步：只有加工对象，系统会自动帮我们创建一个对象，this，并且自动返回；
        + 从函数调用的区别
            1、构造函数，首字母大写，而工厂模式是首字母小写
                + var ary=new Array()  构造函数
                + var person=person()  工厂模式
            2、构造函数有new，工厂模式没有new
    + 关于构造函数需要注意点：
        + 构造函数中的this，指向实例
        + 构造函数中系统会自动帮我们返回，所以，不要自己返回对象;否则，没有我们添加的属性和方法
        + 构造函数属性都是私有属性
        + 构造函数中new出来，都是实例，也都是对象；
    + 构造函数的不足点：对于同一个功能，每创建一个实例，这个功能都是私有的方法；如果创建很多实例，就会造成内存暂用；
    + 解决办法：原型模式；
- 原型模式
1、每个函数数据(类，普通函数)类型，都有一个属性叫做prototype
2、prototype是个对象，这个对象存放公有的属性和方法,它天生自带一个属性，指向当前实例所属的类
3、每个对象数据(object{},prototype,实例)类型，都有一个属性叫__proto__，它指向当前实例所属的类的原型；
- 原型模式重点掌握：1）类   2）实例   3）prototype
### 原型链
我们查找"对象.属性名"的时候
1、先从实例的私有属性开始查找，如果找到，说明该属性是私有属性
2、如果没找到，通过__proto__，去当前实例所属的类的原型上进行查找，找到，说明是公有属性
3、如果没找到，继续通过__proto__继续往上找，一直找到Object.prototype上还没有的话，undefined！











